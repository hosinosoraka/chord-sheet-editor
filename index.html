<!doctype html>
<html lang="ja" class="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>コード譜エディ太</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root{ --staff-stroke:#3b475a; --staff-edge:#55637a; }
    .dark{ --staff-stroke:#cbd5e1; --staff-edge:#94a3b8; }
    body { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
    .chip{ display:inline-flex;align-items:center;border:1px solid #cbd5e1;border-radius:999px;padding:6px 10px;background:#fff;font-weight:700;cursor:grab;user-select:none; touch-action: none; }
    .dark .chip{ background:#0b1220;border-color:#334155;color:#e5e7eb; }
    .item-pill{ position:absolute;transform:translate(-50%,-50%);padding:2px 6px;font-size:11px;border-radius:6px;border:1px solid #cbd5e1;background:#fff;box-shadow:0 1px 2px rgba(0,0,0,.08); touch-action: none; }
    .dark .item-pill{ background:#0b1220;border-color:#334155;color:#e5e7eb;box-shadow:0 1px 2px rgba(0,0,0,.4) }
    .item-pill.scale{ background:#059669;color:#fff;border-color:transparent;transform:translate(-50%, -40%) }
    .dark .item-pill.scale{ background:#059669;color:#fff;border-color:transparent;transform:translate(-50%, -40%) }
    .item-pill.text{ background:#111827; color:#e5e7eb; border-color:#374151; }
    .item-pill.selected{ outline:2px solid #3b82f6; outline-offset:1px; box-shadow:0 0 0 3px rgba(59,130,246,.25) }
    .item-ghost{ position:absolute;transform:translate(-50%,-50%);padding:2px 6px;font-size:11px;border-radius:6px;border:1px dashed #64748b;background:#f8fafc; z-index:50; opacity:.9 }
    .dark .item-ghost{ border-color:#94a3b8;background:#0f172a;color:#e2e8f0 }
    .drag-guide{ position:absolute; top:0; bottom:0; width:1px; background:#60a5fa; opacity:.85; }
    .no-select{ user-select:none;-webkit-user-select:none }
    [contenteditable][data-placeholder]:empty:before{ content: attr(data-placeholder); color: #94a3b8; }
    @media print{
      .print-title{ font-size: 20pt !important; font-weight: 700 !important; margin-bottom: 6pt !important; }
      .print-sub{ font-size: 12pt !important; color: #334155 !important; margin-bottom: 16pt !important; }
      .no-print{ display:none !important; }
    }
  </style>
</head>
<body class="bg-slate-900 text-slate-100">
  <div id="root" class="min-h-screen"></div>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <script>
    const { useRef, useState, useEffect } = React;

    const ROOTS = ["C","C#","Db","D","D#","Eb","E","F","F#","Gb","G","G#","Ab","A","A#","Bb","B"];
    const BASSES = ["", ...ROOTS];
    const BODIES = ["maj","m","7","maj7","m7","m7b5","dim","aug","sus2","sus4","7sus4","add9","6","m6"];
    const TENSIONS = ["", "b9","9","#9","11","#11","b13","13"];

    const SCALE_GROUPS = {
      "Major (Diatonic Modes)": ["Major (Ionian)", "Dorian", "Phrygian", "Lydian", "Mixolydian", "Natural Minor (Aeolian)", "Locrian"],
      "Melodic Minor Modes": ["Melodic Minor","Dorian b2","Lydian #5 (Lydian Augmented)","Lydian b7 (Lydian Dominant)","Mixolydian b6","Aeolian b5","Altered Scale (Super Locrian)"],
      "Harmonic Minor Modes": ["Harmonic Minor","Locrian natural 6","Ionian #5","Dorian #4","Mixolydian b9 b13 (HP5)","Lydian #2","Altered Dominant bb7 (Super Locrian)"],
      "Symmetric (Diminished)": ["Combination Diminished (Half–Whole)","Diminished (Whole–Half)"],
      "Symmetric (Augmented)": ["Augmented Scale"],
      "Pentatonic / Blues": ["Major Pentatonic","Minor Pentatonic","Major Blues Scale","Minor Blues Scale","Dorian Pentatonic","Mixolydian Pentatonic"],
      "Jazz Oriented": ["Harmonic Major","Double Harmonic Major","Whole Tone Scale","Enigmatic Scale","Bebop Major Scale","Bebop Dominant Scale","Bebop Minor Scale"],
      "World Scales": ["Hungarian Minor","Neapolitan Minor","Neapolitan Major","Persian Scale","Arabian Scale","Raga Todi","Japanese Scale (In Sen)","Japanese Scale (In)","Japanese Scale (Yo)"]
    };

    function StaffSVG(){
      const HEIGHT = 40; const GAP = 8;
      return React.createElement('svg', { width:'100%', height:HEIGHT, viewBox:'0 0 1200 '+HEIGHT, preserveAspectRatio:'none', className:'block' },
        React.createElement('g', { transform:'translate(0,0)' },
          [0,1,2,3,4].map(i => React.createElement('line', { key:i, x1:0, y1:i*GAP, x2:1200, y2:i*GAP, stroke:'var(--staff-stroke)', strokeWidth:1.4 }))
          .concat([
            React.createElement('line', { key:'L', x1:0, y1:0, x2:0, y2:HEIGHT, stroke:'var(--staff-edge)', strokeWidth:1.6 }),
            React.createElement('line', { key:'R', x1:1200, y1:0, x2:1200, y2:HEIGHT, stroke:'var(--staff-edge)', strokeWidth:1.6 })
          ])
        )
      );
    }

    // ---------------- Pointer utils ----------------
    function clientXY(ev){
      if (ev && typeof ev.clientX === 'number') return { x: ev.clientX, y: ev.clientY };
      const t = ev?.touches?.[0] || ev?.changedTouches?.[0];
      return { x: t?.clientX ?? 0, y: t?.clientY ?? 0 };
    }

    function MeasureBox(props){
      const {
        rowIdx, index, fr, totalFr, isLast, selected, onSelect,
        onDragBetween, onDragRight, cell, onDropPlace,
        measureRef,
        selection, onItemPointerDown, dragPreview,
        onStartEditText, isEditingText, onEditTextInput, onEditTextBlur, onTextKeyDown
      } = props;

      const FIXED_H = 60, EXTRA = 40;
      const style = { width: ((fr/totalFr)*100) + '%', minWidth: '120px', height: (FIXED_H + EXTRA) + 'px' };

      const parseDragPayload = (e) => {
        try {
          const j = e.dataTransfer?.getData('application/json');
          if (j) {
            const o = JSON.parse(j);
            if (o && (o.type==='chord' || o.type==='scale' || o.type==='text') && typeof o.text==='string') return o;
          }
        } catch {}
        const txt = e.dataTransfer?.getData('text/plain');
        if (txt) return { type:'chord', text: txt };
        return null;
      };

      const onDrop = (e) => {
        e.preventDefault();
        const rect = e.currentTarget.getBoundingClientRect();
        const { x: cx } = clientXY(e);
        const x = Math.min(1, Math.max(0, (cx - rect.left) / rect.width));
        const payload = parseDragPayload(e);
        if (payload) onDropPlace(x, payload);
      };

      const selIsThisMeasure = selection && selection.kind==='measure' && selection.row===rowIdx && selection.col===index;

      return React.createElement('div', {
        ref: measureRef,
        onClick: onSelect,
        onDragOver: (e)=>e.preventDefault(),
        onDrop,
        className: 'relative flex-shrink-0 group cursor-pointer ' + ((selected||selIsThisMeasure) ? 'ring-2 ring-blue-500' : ''),
        style
      },
        React.createElement('div', { className:'absolute left-0 right-0', style:{ top:'35px' } }, React.createElement(StaffSVG,null)),

        /* コード（上） */
        React.createElement('div', { className:'absolute left-0 right-0', style:{ top:'20px' } },
          (cell.chords||[]).map((c, idx) => {
            const isSelected = selection && selection.kind==='item' && selection.type==='chord' && selection.row===rowIdx && selection.col===index && selection.index===idx;
            return React.createElement('span', {
                key:idx,
                className:'item-pill ' + (isSelected ? 'selected ' : ''),
                style:{ left:(c.x*100)+'%', touchAction:'none' },
                onPointerDown:(e)=>{ e.stopPropagation(); onItemPointerDown('chord', idx, e); },
                onClick:(e)=>{ e.stopPropagation(); },
                draggable:false,
                onDragStart:(e)=>e.preventDefault()
            }, c.text);
          })
        ),

        /* テキスト（中間） */
        React.createElement('div', { className:'absolute left-0 right-0', style:{ top:(FIXED_H/2+20)+'px' } },
          (cell.texts||[]).map((t, idx) => {
            const isSelected = selection && selection.kind==='item' && selection.type==='text' && selection.row===rowIdx && selection.col===index && selection.index===idx;
            const editing = isEditingText && isEditingText.row===rowIdx && isEditingText.col===index && isEditingText.index===idx;
            return React.createElement('span', {
                key:idx,
                className:'item-pill text ' + (isSelected ? 'selected ' : ''),
                style:{ left:(t.x*100)+'%', minWidth:'28px', touchAction:'none' },
                onPointerDown:(e)=>{ if (!editing){ e.stopPropagation(); onItemPointerDown('text', idx, e); } },
                onDoubleClick:(e)=>{ 
                  e.stopPropagation(); 
                  onStartEditText(rowIdx, index, idx); 
                  requestAnimationFrame(()=>{
                    const el = e.currentTarget;
                    if (!el) return;
                    el.textContent = t.text || '';
                    el.focus();
                    const r = document.createRange();
                    r.selectNodeContents(el);
                    r.collapse(false);
                    const sel = window.getSelection();
                    sel.removeAllRanges();
                    sel.addRange(r);
                  });
                },
                onClick:(e)=>{ e.stopPropagation(); },
                draggable:false,
                onDragStart:(e)=>e.preventDefault(),
                contentEditable: editing ? 'plaintext-only' : false,
                onFocus: editing ? (e)=>{ if(!e.currentTarget.textContent){ e.currentTarget.textContent = t.text || ''; } } : undefined,
                suppressContentEditableWarning: true,
                onInput: editing ? (e)=> onEditTextInput(rowIdx, index, idx, e.currentTarget.textContent || '') : undefined,
                onBlur:(e)=> onEditTextBlur(),
                onKeyDown:(e)=> onTextKeyDown(e),
                'data-placeholder':'Text'
            }, editing ? null : t.text);
          })
        ),

        /* スケール（下） */
        React.createElement('div', { className:'absolute left-0 right-0', style:{ top:(FIXED_H+20)+'px' } },
          (cell.scales||[]).map((s, idx) => {
            const isSelected = selection && selection.kind==='item' && selection.type==='scale' && selection.row===rowIdx && selection.col===index && selection.index===idx;
            return React.createElement('span', {
                key:idx,
                className:'item-pill scale ' + (isSelected ? 'selected ' : ''),
                style:{ left:(s.x*100)+'%', touchAction:'none' },
                onPointerDown:(e)=>{ e.stopPropagation(); onItemPointerDown('scale', idx, e); },
                onClick:(e)=>{ e.stopPropagation(); },
                draggable:false,
                onDragStart:(e)=>e.preventDefault()
            }, s.text);
          })
        ),

        (dragPreview && dragPreview.active && dragPreview.row===rowIdx && dragPreview.col===index) && React.createElement('div', {
          className:'absolute left-0 right-0 pointer-events-none',
          style:{ top: dragPreview.type==='chord' ? '20px' : dragPreview.type==='scale' ? (FIXED_H+6)+'px' : (FIXED_H/2 - 6)+'px' }
        },
          React.createElement('div', { className:'drag-guide', style:{ left:(dragPreview.x*100)+'%' } }),
          React.createElement('span', { className: 'item-ghost ' + (dragPreview.type==='scale'?'scale':'') + (dragPreview.type==='text'?' text':''), style:{ left:(dragPreview.x*100)+'%' } }, dragPreview.text)
        ),

        (!isLast && React.createElement('div', { onPointerDown:onDragBetween, className:'absolute top-0 right-0 h-full w-2 cursor-col-resize bg-transparent z-10', style:{ touchAction:'none' } },
          React.createElement('div', { className:'absolute inset-y-4 right-0 w-px bg-slate-600/70' })
        )),
        (isLast && React.createElement('div', { onPointerDown:onDragRight, className:'absolute top-0 right-0 h-full w-2 cursor-col-resize bg-transparent z-10', style:{ touchAction:'none' } },
          React.createElement('div', { className:'absolute inset-y-4 right-0 w-px bg-slate-600/70' })
        ))
      );
    }

    const APP_VERSION = "V1.1.1 (Pointer Events, text-edit fix)";

    function App(){
      const containerRef = useRef(null);
      const rowsRef = useRef([]);
      const measureRefs = useRef([]);
      const [rows, setRows] = useState([[1]]);
      const [selected, setSelected] = useState(null);
      const MIN_FR = 0.35;

      const [titleText, setTitleText] = useState('タイトル');
      const [scoreKey, setScoreKey] = useState('');
      const titleRef = useRef(null);

      useEffect(()=>{ document.title = `コード譜エディ太`; }, []);
      const [selection, setSelection] = useState(null);

      const [keySel, setKeySel] = useState('C');
      const [scaleSel, setScaleSel] = useState('Major (Ionian)');
      const [chKey, setChKey] = useState('C');
      const [chBody, setChBody] = useState('maj');
      const [chTension, setChTension] = useState('');
      const [chBass, setChBass] = useState('');

      const [placements, setPlacements] = useState([[ { chords: [], texts: [], scales: [] } ]]);
      const [editingText, setEditingText] = useState(null);

      const fileInputRef = useRef(null);

      const DRAG_THRESHOLD_PX = 3;
      const [dragState, setDragState] = useState({
        active:false, type:null, text:'', from:null, to:null,
        offsetX:0, startX:0, startY:0, moved:false
      });

      useEffect(()=>{ measureRefs.current = rows.map(()=>[]); }, [rows.length]);

      const chordLabel = () => {
        const q = (chBody==='maj') ? '' : chBody;
        const t = chTension ? '('+chTension+')' : '';
        const b = chBass ? '/'+chBass : '';
        return chKey + q + t + b;
      };
      const scaleLabel = () => keySel + ' ' + scaleSel;

      const pxToFr = (rowIdx, px, totalFr) => {
        const w = (rowsRef.current[rowIdx] && rowsRef.current[rowIdx].clientWidth) || (containerRef.current && containerRef.current.clientWidth) || 1;
        return (px / w) * totalFr;
      };

      const addMeasureHorizontal = (rowIdx, index) => {
        setRows(prev => prev.map((r, ri) => {
          if (ri !== rowIdx) return r;
          const next = r.slice();
          const half = Math.max(MIN_FR, next[index] / 2);
          next[index] = half; next.splice(index + 1, 0, half);
          return next;
        }));
        setPlacements(prev => prev.map((prow, pri) => {
          if (pri !== rowIdx) return prow;
          const next = prow.map(c => ({ chords:[...c.chords], texts:[...c.texts], scales:[...c.scales] }));
          next.splice(index + 1, 0, { chords: [], texts: [], scales: [] });
          return next;
        }));
        setSelected({ row: rowIdx, col: index + 1 });
        setSelection({ kind:'measure', row: rowIdx, col: index + 1 });
      };

      const addMeasureVertical = (rowIdx) => {
        setRows(prev => { const copy = prev.slice(); copy.splice(rowIdx + 1, 0, [1]); return copy; });
        setPlacements(prev => { const copy = prev.map(row => row.map(c => ({ chords:[...c.chords], texts:[...c.texts], scales:[...c.scales] }))); copy.splice(rowIdx + 1, 0, [ { chords: [], texts: [], scales: [] } ]); return copy; });
        setSelected({ row: rowIdx + 1, col: 0 });
        setSelection({ kind:'measure', row: rowIdx + 1, col: 0 });
      };

      const deleteItem = (sel)=>{
        setPlacements(prev => prev.map((prow, rIdx) => {
          if (rIdx !== sel.row) return prow;
          return prow.map((cell, cIdx) => {
            if (cIdx !== sel.col) return cell;
            const next = { chords:[...cell.chords], texts:[...cell.texts], scales:[...cell.scales] };
            if (sel.type==='chord') next.chords.splice(sel.index,1);
            else if (sel.type==='scale') next.scales.splice(sel.index,1);
            else next.texts.splice(sel.index,1);
            return next;
          });
        }));
        setSelection(null);
      };

      const clearMeasure = (rowIdx, colIdx)=>{
        setPlacements(prev => prev.map((prow, rIdx) => {
          if (rIdx !== rowIdx) return prow;
          return prow.map((cell, cIdx) => (cIdx===colIdx ? { chords:[], texts:[], scales:[] } : cell));
        }));
        setSelection(null);
      };

      function deleteMeasure(rowIdx, colIdx){
        if (rows.length === 1 && rows[0].length === 1) {
          clearMeasure(0, 0);
          setSelected({ row:0, col:0 });
          setSelection({ kind:'measure', row:0, col:0 });
          return;
        }
        setRows(prev => {
          const copy = prev.map(r => r.slice());
          if (!copy[rowIdx]) return prev;
          copy[rowIdx].splice(colIdx, 1);
          if (copy[rowIdx].length === 0) copy.splice(rowIdx, 1);
          return copy;
        });
        setPlacements(prev => {
          const copy = prev.map(row => row.map(c => ({ chords:[...c.chords], texts:[...c.texts], scales:[...c.scales] })));
          if (!copy[rowIdx]) return prev;
          copy[rowIdx].splice(colIdx, 1);
          if (copy[rowIdx].length === 0) copy.splice(rowIdx, 1);
          return copy;
        });
        setSelection(null);
        setSelected(null);
      }

      const dropPlace = (rowIdx, colIdx, x, payload) => {
        let type = (payload && (payload.type==='scale' || payload.type==='chord' || payload.type==='text')) ? payload.type : 'chord';
        let text = (payload && typeof payload.text==='string') ? payload.text : (type==='chord' ? chordLabel() : type==='scale' ? scaleLabel() : 'Text');
        placeNewItem(type, rowIdx, colIdx, x, text);
      };

      function placeNewItem(type, rowIdx, colIdx, x, text){
        setPlacements(prev => prev.map((prow, rIdx) => {
          if (rIdx !== rowIdx) return prow;
          const nextRow = prow.map(c => ({ chords:[...c.chords], texts:[...c.texts], scales:[...c.scales] }));
          const target = nextRow[colIdx] || { chords: [], texts: [], scales: [] };
          if (type === 'chord') target.chords.push({ x, text });
          else if (type === 'scale') target.scales.push({ x, text });
          else target.texts.push({ x, text });
          nextRow[colIdx] = target;
          return nextRow;
        }));
      }

      // ---------- Text edit handlers (restored) ----------
      function onStartEditText(row, col, index){
        setEditingText({ row, col, index });
        setSelection({ kind:'item', type:'text', row, col, index });
      }
      function onEditTextInput(row, col, index, value){
        setPlacements(prev => prev.map((prow, rIdx) => {
          if (rIdx !== row) return prow;
          return prow.map((cell, cIdx) => {
            if (cIdx !== col) return cell;
            const next = { chords:[...cell.chords], texts:cell.texts.map((t,i)=> i===index? ({...t, text:value}) : t), scales:[...cell.scales] };
            return next;
          });
        }));
      }
      function onEditTextBlur(){
        setEditingText(null);
      }
      function onTextKeyDown(e){
        if (e.key === 'Enter'){ e.preventDefault(); e.currentTarget.blur(); }
        else if (e.key === 'Escape'){ e.preventDefault(); e.currentTarget.blur(); }
      }

      // ---------- Item drag (Pointer Events) ----------
      function onItemPointerDownFactory(rowIdx, colIdx){
        return (type, itemIndex, e) => {
          e.preventDefault();
          setEditingText(null);
          setSelection({ kind:'item', type, row:rowIdx, col:colIdx, index:itemIndex });

          const ref = measureRefs.current[rowIdx]?.[colIdx];
          if (!ref) return;
          const rect = ref.getBoundingClientRect();

          const cell = (placements[rowIdx] && placements[rowIdx][colIdx]) || { chords:[], texts:[], scales:[] };
          const list = type==='chord' ? cell.chords : (type==='scale' ? cell.scales : cell.texts);
          const src = list[itemIndex];
          if (!src) return;

          const { x: cx, y: cy } = clientXY(e);
          const xInMeasure = Math.min(1, Math.max(0, (cx - rect.left) / rect.width));
          e.currentTarget?.setPointerCapture?.(e.pointerId);

          setDragState({
            active:true, type, text: src.text,
            from:{ row: rowIdx, col: colIdx, index: itemIndex, x: src.x },
            to:{ row: rowIdx, col: colIdx, x: xInMeasure },
            offsetX: xInMeasure - src.x,
            startX: cx, startY: cy, moved:false
          });

          const onMove = (ev)=>{
            setDragState(prev => {
              if (!prev.active) return prev;
              const { x: mx, y: my } = clientXY(ev);
              const moved = prev.moved ||
                Math.abs(mx - (prev.startX||0)) > 3 ||
                Math.abs(my - (prev.startY||0)) > 3;
              if (!moved) return prev;

              for (let r=0; r<measureRefs.current.length; r++){
                const rowArr = measureRefs.current[r] || [];
                for (let c=0; c<rowArr.length; c++){
                  const el = rowArr[c];
                  if (!el) continue;
                  const rct = el.getBoundingClientRect();
                  if (mx >= rct.left && mx <= rct.right && my >= rct.top && my <= rct.bottom){
                    const x = Math.min(1, Math.max(0, (mx - rct.left) / rct.width));
                    return { ...prev, moved:true, to: { row: r, col: c, x } };
                  }
                }
              }
              return prev;
            });
          };

          const onUp = ()=>{
            setDragState(prev => {
              if (!prev.active) return prev;
              const { type, text, from, to } = prev;
              const cleanup = () => {
                window.removeEventListener('pointermove', onMove, { passive:false });
                window.removeEventListener('pointerup', onUp, { passive:false });
                try{ e.currentTarget?.releasePointerCapture?.(e.pointerId); }catch{}
                document.body.classList.remove('no-select');
              };
              if (!to || typeof to.row!== 'number' || typeof to.col!== 'number') {
                cleanup();
                return { active:false, type:null, text:'', from:null, to:null, offsetX:0, startX:0, startY:0, moved:false };
              }
              if (!prev.moved) {
                setSelection({ kind:'item', type, row: from.row, col: from.col, index: from.index });
                cleanup();
                return { active:false, type:null, text:'', from:null, to:null, offsetX:0, startX:0, startY:0, moved:false };
              }
              let insertedIndex = 0;
              setPlacements(old => {
                const removed = old.map((prow, rIdx) => {
                  if (rIdx !== from.row) return prow;
                  return prow.map((cell, cIdx) => {
                    if (cIdx !== from.col) return cell;
                    const next = { chords:[...cell.chords], texts:[...cell.texts], scales:[...cell.scales] };
                    if (type==='chord') next.chords.splice(from.index, 1);
                    else if (type==='scale') next.scales.splice(from.index, 1);
                    else next.texts.splice(from.index, 1);
                    return next;
                  });
                });
                const placed = removed.map((prow, rIdx) => {
                  if (rIdx !== to.row) return prow;
                  return prow.map((cell, cIdx) => {
                    if (cIdx !== to.col) return cell;
                    const next = { chords:[...cell.chords], texts:[...cell.texts], scales:[...cell.scales] };
                    if (type==='chord') { next.chords.push({ x: to.x, text }); insertedIndex = next.chords.length - 1; }
                    else if (type==='scale') { next.scales.push({ x: to.x, text }); insertedIndex = next.scales.length - 1; }
                    else { next.texts.push({ x: to.x, text }); insertedIndex = next.texts.length - 1; }
                    return next;
                  });
                });
                return placed;
              });
              setSelection({ kind:'item', type, row: to.row, col: to.col, index: insertedIndex });
              cleanup();
              return { active:false, type:null, text:'', from:null, to:null, offsetX:0, startX:0, startY:0, moved:false };
            });
          };

          window.addEventListener('pointermove', onMove, { passive:false });
          window.addEventListener('pointerup', onUp, { passive:false });
          document.body.classList.add('no-select');
        };
      }

      const onItemPointerDown = (rowIdx, colIdx) => onItemPointerDownFactory(rowIdx, colIdx);

      useEffect(()=>{
        const isTypingInEditable = () => {
          const ae = document.activeElement;
          if (!ae) return false;
          const tag = ae.tagName;
          if (tag === 'INPUT' || tag === 'TEXTAREA') return true;
          if (ae.isContentEditable) return true;
          return false;
        };
        const onKeyDown = (e)=>{ if (isTypingInEditable()) return;
          if (e.key === 'Delete' || e.key === 'Backspace') {
            if (!selection) return;
            if (selection.kind === 'item') {
              e.preventDefault();
              deleteItem(selection);
            } else if (selection.kind === 'measure') {
              if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                deleteMeasure(selection.row, selection.col);
              } else if (e.shiftKey) {
                e.preventDefault();
                clearMeasure(selection.row, selection.col);
              } else {
                e.preventDefault();
              }
            }
          } else if (e.key === 'Escape') {
            setEditingText(null);
            setSelection(null);
          }
        };
        window.addEventListener('keydown', onKeyDown);
        return ()=>window.removeEventListener('keydown', onKeyDown);
      }, [selection]);

      useEffect(()=>{
        window.__getRows = () => rows;
        window.__getPlacements = () => placements;
        return () => { delete window.__getRows; delete window.__getPlacements; };
      }, [rows, placements]);

      function exportJson(){
        const data = {
          schema: "chord-sheet.v1",
          title: titleText || "",
          scoreKey: scoreKey || "",
          rows: window.__getRows?.() || [[1]],
          placements: window.__getPlacements?.() || [[{ chords:[], texts:[], scales:[] }]],
          savedAt: new Date().toISOString()
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = (titleText && titleText.trim()) ? `${titleText}.json` : "score.json";
        a.click();
        URL.revokeObjectURL(url);
      }

      function importJsonFromFile(file){
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const parsed = JSON.parse(String(reader.result || "{}"));
            if (!parsed || typeof parsed !== "object") throw new Error("Invalid JSON");
            if (!Array.isArray(parsed.rows) || !Array.isArray(parsed.placements)) {
              throw new Error("rows / placements が見つかりません");
            }
            if (parsed.placements.length !== parsed.rows.length) {
              throw new Error("rows と placements の行数が一致しません");
            }
            const fixedPlacements = parsed.placements.map((prow, i) => {
              const cols = (Array.isArray(parsed.rows[i]) ? parsed.rows[i].length : 0) || 0;
              const safeRow = Array.isArray(prow) ? prow.slice() : [];
              while (safeRow.length < cols) safeRow.push({ chords:[], texts:[], scales:[] });
              if (safeRow.length > cols) safeRow.length = cols;
              return safeRow.map(cell => ({
                chords: Array.isArray(cell?.chords) ? cell.chords : [],
                texts:  Array.isArray(cell?.texts)  ? cell.texts  : [],
                scales: Array.isArray(cell?.scales) ? cell.scales : []
              }));
            });
            setRows(parsed.rows.map(r => Array.isArray(r) ? r.slice() : [1]));
            setPlacements(fixedPlacements);
            if (typeof parsed.title === "string") setTitleText(parsed.title);
            if (typeof parsed.scoreKey === "string") setScoreKey(parsed.scoreKey);
            setSelected({ row:0, col:0 });
            setSelection({ kind:"measure", row:0, col:0 });
          } catch (err){
            alert("JSON読み込みに失敗しました: " + (err?.message || err));
          }
        };
        reader.readAsText(file, "utf-8");
      }

      function onClickLoadJson(){ fileInputRef.current?.click(); }
      function onFileInputChange(e){
        const f = e.target.files?.[0];
        importJsonFromFile(f);
        e.target.value = "";
      }

      // ---------- Measure border drag (Pointer Events) ----------
      function startDragBetween(ev, rowIdx, leftIndex){
        ev.preventDefault(); ev.stopPropagation();
        ev.currentTarget?.setPointerCapture?.(ev.pointerId);
        const { x: startX } = clientXY(ev);
        const startRow = rows[rowIdx].slice();
        const totalFr = startRow.reduce((a,b)=>a+b,0) || 1;
        const pairTotal = startRow[leftIndex] + startRow[leftIndex+1];

        const onMove = (e) => {
          const { x: cx } = clientXY(e);
          const dxFr = pxToFr(rowIdx, cx - startX, totalFr);
          let L = startRow[leftIndex] + dxFr;
          if (L < MIN_FR) L = MIN_FR;
          if (L > pairTotal - MIN_FR) L = pairTotal - MIN_FR;

          const nextRow = startRow.slice();
          nextRow[leftIndex]   = L;
          nextRow[leftIndex+1] = pairTotal - L;
          setRows(prev => prev.map((r, ri) => (ri === rowIdx ? nextRow : r)));
        };

        const onUp = () => {
          window.removeEventListener('pointermove', onMove, { passive:false });
          window.removeEventListener('pointerup', onUp, { passive:false });
          try{ ev.currentTarget?.releasePointerCapture?.(ev.pointerId); }catch{}
        };

        window.addEventListener('pointermove', onMove, { passive:false });
        window.addEventListener('pointerup', onUp, { passive:false });
      }

      function startDragRightEdge(ev, rowIdx, index){
        ev.preventDefault(); ev.stopPropagation();
        ev.currentTarget?.setPointerCapture?.(ev.pointerId);
        const { x: startX } = clientXY(ev);
        const startRow = rows[rowIdx].slice();
        const totalBefore = startRow.reduce((a,b)=>a+b,0);

        const onMove = (e) => {
          const { x: cx } = clientXY(e);
          let W = startRow[index] + pxToFr(rowIdx, cx - startX, totalBefore);
          if (W < MIN_FR) W = MIN_FR;

          const nextRow = startRow.slice();
          nextRow[index] = W;

          const rest = nextRow.reduce((a,b)=>a+b,0);
          for (let i=0;i<nextRow.length;i++) nextRow[i] = nextRow[i] * totalBefore / rest;
          setRows(prev => prev.map((r, ri) => (ri === rowIdx ? nextRow : r)));
        };

        const onUp = () => {
          window.removeEventListener('pointermove', onMove, { passive:false });
          window.removeEventListener('pointerup', onUp, { passive:false });
          try{ ev.currentTarget?.releasePointerCapture?.(ev.pointerId); }catch{}
        };

        window.addEventListener('pointermove', onMove, { passive:false });
        window.addEventListener('pointerup', onUp, { passive:false });
      }

      return React.createElement('div', { className:'min-h-screen bg-slate-900 text-slate-100 flex' },
        
        React.createElement('aside', { className:'w-1/4 border-r border-slate-700 bg-slate-800 p-4 space-y-6 no-print' },
          React.createElement('div', { className:'flex flex-col items-center mb-4' },
            React.createElement('h1', { className:'text-lg font-bold text-slate-100 mb-1' }, 'コード譜エディ太'),
            React.createElement('div', { className:'text-sm text-slate-400' }, APP_VERSION)
          ),
          React.createElement('section', { className:'bg-slate-800 border border-slate-700 rounded-2xl shadow-sm p-4 space-y-4' },
            React.createElement('h2', { className:'text-sm font-medium text-slate-300' }, 'キー / スケール（リスト）'),
            React.createElement('div', { className:'grid grid-cols-2 gap-3' },
              React.createElement('label', { className:'text-xs text-slate-300' }, 'Key',
                React.createElement('select', { value:keySel, onChange:e=>setKeySel(e.target.value), className:'mt-1 w-full border rounded-md px-2 py-1 text-sm bg-slate-900 border-slate-700' },
                  ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"].map(k => React.createElement('option', { key:k, value:k }, k))
                )
              ),
              React.createElement('label', { className:'text-xs text-slate-300' }, 'Scale',
                React.createElement('select', { value:scaleSel, onChange:e=>setScaleSel(e.target.value), className:'mt-1 w-full border rounded-md px-2 py-1 text-sm bg-slate-900 border-slate-700' },
                  Object.entries(SCALE_GROUPS).map(([group, list]) =>
                    React.createElement('optgroup', { key: group, label: group },
                      list.map(name => React.createElement('option', { key:name, value:name }, name))
                    )
                  )
                )
              )
            ),
            React.createElement('div', { className:'flex flex-col items-start gap-1' },
              React.createElement('span', { className:'chip', draggable:true,
                onDragStart:(e)=>{ const payload={ type:'scale', text: keySel + ' ' + scaleSel }; e.dataTransfer.setData('application/json', JSON.stringify(payload)); e.dataTransfer.setData('text/plain', payload.text); } },
                keySel + ' ' + scaleSel
              ),
              React.createElement('span', { className:'text-[11px] text-slate-400' }, 'スケールを小節へドラッグ')
            )
          ),
          React.createElement('section', { className:'bg-slate-800 border border-slate-700 rounded-2xl shadow-sm p-4 space-y-3' },
            React.createElement('h2', { className:'text-sm font-medium text-slate-300' }, 'コード作成（キー / コード本体 / テンション / ベース）'),
            React.createElement('div', { className:'grid grid-cols-2 gap-3' },
              React.createElement('label', { className:'text-xs text-slate-300' }, 'Key',
                React.createElement('select', { value:chKey, onChange:e=>setChKey(e.target.value), className:'mt-1 w-full border rounded-md px-2 py-1 text-sm bg-slate-900 border-slate-700' },
                  ROOTS.map(r => React.createElement('option', { key:r, value:r }, r))
                )
              ),
              React.createElement('label', { className:'text-xs text-slate-300' }, 'コード本体',
                React.createElement('select', { value:chBody, onChange:e=>setChBody(e.target.value), className:'mt-1 w-full border rounded-md px-2 py-1 text-sm bg-slate-900 border-slate-700' },
                  BODIES.map(b => React.createElement('option', { key:b, value:b }, b))
                )
              ),
              React.createElement('label', { className:'text-xs text-slate-300' }, 'テンション',
                React.createElement('select', { value:chTension, onChange:e=>setChTension(e.target.value), className:'mt-1 w-full border rounded-md px-2 py-1 text-sm bg-slate-900 border-slate-700' },
                  TENSIONS.map(t => React.createElement('option', { key:t||'(none)', value:t }, t || '(none)'))
                )
              ),
              React.createElement('label', { className:'text-xs text-slate-300' }, 'ベース',
                React.createElement('select', { value:chBass, onChange:e=>setChBass(e.target.value), className:'mt-1 w-full border rounded-md px-2 py-1 text-sm bg-slate-900 border-slate-700' },
                  BASSES.map(b => React.createElement('option', { key:b||'(none)', value:b }, b || '(none)'))
                )
              )
            ),
            React.createElement('div', { className:'flex flex-col items-start gap-1' },
              React.createElement('span', { className:'chip', draggable:true,
                onDragStart:(e)=>{ const q=(chBody==='maj')?'':chBody; const t=chTension?('('+chTension+')'):''; const b=chBass?('/'+chBass):''; const payload={ type:'chord', text: chKey + q + t + b }; e.dataTransfer.setData('application/json', JSON.stringify(payload)); e.dataTransfer.setData('text/plain', payload.text); } },
                (function(){ const q=(chBody==='maj')?'':chBody; const t=chTension?('('+chTension+')'):''; const b=chBass?('/'+chBass):''; return chKey + q + t + b; })()
              ),
              React.createElement('span', { className:'text-[11px] text-slate-400' }, 'コードを小節へドラッグ')
            )
          ),
          React.createElement('section', { className:'bg-slate-800 border border-slate-700 rounded-2xl shadow-sm p-4 space-y-3' },
            React.createElement('h2', { className:'text-sm font-medium text-slate-300' }, 'テキスト'),
            React.createElement('div', { className:'flex flex-col items-start gap-1' },
              React.createElement('span', { className:'chip', draggable:true,
                onDragStart:(e)=>{ const payload={ type:'text', text:'Text' }; e.dataTransfer.setData('application/json', JSON.stringify(payload)); e.dataTransfer.setData('text/plain', payload.text); } },
                'Text'
              ),
              React.createElement('span', { className:'text-[11px] text-slate-400' }, 'テキストのチップを小節へドラッグ（ダブルクリックで編集）')
            )
          ),
          React.createElement('div', { className:'text-center mt-3' },
            React.createElement('a', {
              href:'https://github.com/hosinosoraka/chord-sheet-editor/blob/main/README.md',
              target:'_blank',
              rel:'noopener noreferrer',
              className:'inline-block text-xs text-blue-400 hover:underline'
            }, '📖 ReadMe')
          )
        ),
        React.createElement('main', { className:'flex-1 min-w-0 p-6', ref: containerRef },
          React.createElement('div', { className:'bg-slate-800 border border-slate-700 rounded-2xl shadow-sm p-4' },
            React.createElement('div', { className:'mb-2 flex flex-wrap items-start justify-between gap-2' },
              React.createElement('div', { className:'flex-1 min-w-[260px]' },
                React.createElement('input', {
                  ref: titleRef,
                  type:'text',
                  value: titleText,
                  onChange:(e)=> setTitleText(e.target.value),
                  placeholder:'タイトルを入力',
                  className:'print-title border rounded px-2 py-1 text-lg font-semibold w-full bg-slate-900 border-slate-700 text-slate-100 placeholder-slate-500'
                }),
                React.createElement('div', { className:'print-sub mt-1 flex items-center gap-2' },
                  React.createElement('label', { className:'text-xs text-slate-300' }, 'Key:'),
                  React.createElement('input', {
                    type:'text', value:scoreKey, onChange:(e)=>setScoreKey(e.target.value), placeholder:'例: C / G / Fm など',
                    className:'border rounded px-2 py-1 text-sm w-56 sm:w-64 md:w-80 lg:w-[28rem] flex-shrink-0 bg-slate-900 border-slate-700 text-slate-100 placeholder-slate-500'
                  })
                )
              ),
              React.createElement('div', { className:'flex gap-2 items-start flex-shrink-0' },
                React.createElement('button', { onClick:()=>{ if(selected){ addMeasureHorizontal(selected.row, selected.col); } }, disabled:!selected || (selected && rows[selected.row].length>=4), className:'px-2 py-1 rounded bg-green-600 text-white text-xs disabled:opacity-40' }, '+ 横に追加'),
                React.createElement('button', { onClick:()=>{ if(selected){ addMeasureVertical(selected.row); } }, disabled:!selected, className:'px-2 py-1 rounded bg-blue-600 text-white text-xs disabled:opacity-40' }, '+ 下に追加'),
                React.createElement('button', {
                  onClick:()=>{ if (!selection) return; if (selection.kind==="item") deleteItem(selection); },
                  disabled:!selection || selection.kind!=='item',
                  className:'px-2 py-1 rounded bg-red-600 text-white text-xs disabled:opacity-40',
                  title:'選択中のコード/スケール/テキスト（1個）だけを削除（DeleteでもOK）'
                }, '描画削除(shift+delで小節内全削除)'),
                React.createElement('button', {
                  onClick:()=>{ if (!selection) return; if (selection.kind==="measure") deleteMeasure(selection.row, selection.col); },
                  disabled:!selection || selection.kind!=='measure',
                  className:'px-2 py-1 rounded bg-rose-600 text-white text-xs disabled:opacity-40',
                  title:'小節そのものを削除（ショートカット: Ctrl/Cmd + Delete）'
                }, '小節削除（Ctrl + Delete）'),
                React.createElement('button', { onClick:exportPdf, className:'px-3 py-1.5 rounded bg-indigo-600 hover:bg-indigo-500 text-white text-xs' }, 'PDF書き出し'),
                React.createElement('button', { onClick:exportJson, className:'px-3 py-1.5 rounded bg-amber-600 hover:bg-amber-500 text-white text-xs' }, 'JSON保存'),
                React.createElement('button', { onClick:onClickLoadJson, className:'px-3 py-1.5 rounded bg-slate-600 hover:bg-slate-500 text-white text-xs' }, 'JSON読み込み'),
                React.createElement('input', { ref:fileInputRef, type:'file', accept:'application/json', onChange:onFileInputChange, style:{ display:'none' } })
              )
            ),
            React.createElement('div', { className:'space-y-3' },
              rows.map((row, rowIdx) => {
                const total = row.reduce((a,b)=>a+b,0) || 1;
                return React.createElement('div', { key:rowIdx, ref:el=>rowsRef.current[rowIdx]=el, className:'relative flex gap-0 items-stretch overflow-hidden rounded-xl border border-slate-700' },
                  row.map((fr, i) => {
                    const cell = (placements[rowIdx] && placements[rowIdx][i]) || { chords: [], texts: [], scales: [] };
                    if (!measureRefs.current[rowIdx]) measureRefs.current[rowIdx] = [];
                    return React.createElement(MeasureBox, {
                      key:i,
                      rowIdx, index:i, fr, totalFr:total,
                      isLast: i === row.length - 1,
                      selected: selected && selected.row === rowIdx && selected.col === i,
                      selection: selection,
                      onSelect: () => { setSelected({row: rowIdx, col: i}); setSelection({kind:'measure', row:rowIdx, col:i}); },
                      onDragBetween: (e) => { if (i < row.length - 1) startDragBetween(e, rowIdx, i); },
                      onDragRight: (e) => { if (i === row.length - 1) startDragRightEdge(e, rowIdx, i); },
                      cell: cell,
                      onDropPlace: (x, payload) => dropPlace(rowIdx, i, x, payload),
                      measureRef: (el)=>{ measureRefs.current[rowIdx][i] = el; },
                      onItemPointerDown: onItemPointerDown(rowIdx, i),
                      dragPreview: dragState.active ? { ...dragState, row: dragState.to?.row, col: dragState.to?.col, x: dragState.to?.x } : null,
                      onStartEditText,
                      isEditingText: editingText,
                      onEditTextInput,
                      onEditTextBlur,
                      onTextKeyDown
                    });
                  })
                );
              })
            )
          )
        )
      );
    }


    // ---------------- PDF Section ----------------
    function addJPFonts(doc){
      try{
        if (window.NOTO_SANS_JP_REG && window.NOTO_SANS_JP_BOLD){
          doc.addFileToVFS('NotoSansJP-Regular.ttf', window.NOTO_SANS_JP_REG);
          doc.addFont('NotoSansJP-Regular.ttf', 'NotoSansJP', 'normal');
          doc.addFileToVFS('NotoSansJP-Bold.ttf', window.NOTO_SANS_JP_BOLD);
          doc.addFont('NotoSansJP-Bold.ttf', 'NotoSansJP', 'bold');
          return 'NotoSansJP';
        }
      }catch(e){}
      return 'helvetica';
    }

    function exportPdf(){
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({ unit:'mm', format:'a4', orientation:'landscape', compress:true });

      const fontName = addJPFonts(doc);
      doc.setFont(fontName, 'normal');

      const pageW = doc.internal.pageSize.getWidth();
      const pageH = doc.internal.pageSize.getHeight();
      const margin = { top:18, right:15, bottom:18, left:15 };
      const contentW = pageW - margin.left - margin.right;

      const titleEl = document.querySelector('.print-title');
      const keyEl = document.querySelector('input[placeholder="例: C / G / Fm など"]');
      const titleText = ((titleEl?.value ?? titleEl?.textContent) || '').trim();
      const scoreKey  = keyEl?.value || '';

      const rowsState       = window.__getRows?.() || [[1]];
      const placementsState = window.__getPlacements?.() || [[{chords:[],texts:[],scales:[]}]];

      function measureTextMm(txt, pt, bold){
        const prev = { size: doc.internal.getFontSize(), name: doc.getFont().fontName, style: doc.getFont().fontStyle };
        doc.setFont(fontName, bold ? 'bold' : 'normal');
        doc.setFontSize(pt);
        const wMm = doc.getTextDimensions(String(txt||'')).w;
        doc.setFont(prev.name, prev.style);
        doc.setFontSize(prev.size);
        return wMm;
      }

      function textAt(txt, x, y, {align='left', bold=false, pt=10, maxWmm=null}={}){
        let size = pt;
        let w = measureTextMm(txt, size, bold);
        if (maxWmm && w > maxWmm){
          while (w > maxWmm && size > pt*0.8){
            size -= 0.5;
            w = measureTextMm(txt, size, bold);
          }
        }
        doc.setFont(fontName, bold?'bold':'normal');
        doc.setFontSize(size);
        let x0 = x;
        if (align==='center') x0 = x - w/2;
        else if (align==='right') x0 = x - w;
        doc.text(String(txt||''), x0, y);
      }

      function drawTextWithBox(txt, x, y, pt=9){
        const pad = 1.2;
        const w = measureTextMm(txt, pt, false);
        const h = pt * 0.42 * 1.2;
        doc.setFillColor(255,255,255);
        doc.rect(x - w/2 - pad, y - h + pad*0.6, w + pad*2, h, 'F');
        doc.setTextColor(0,0,0);
        textAt(txt, x, y, {align:'center', pt});
      }

      function line(x1,y1,x2,y2,w=0.35){ doc.setLineWidth(w); doc.line(x1,y1,x2,y2); }

      function abbreviateScaleName(txt){
        const repl = [
          [/Lydian b7\s*\(Lyd\.?\s*Dominant\)/gi, 'Lyd. b7'],
          [/Lydian #5\s*\(Lyd\.?\s*Augmented\)/gi, 'Lyd. #5'],
          [/Locrian natural 6/gi, 'Locrian nat.6'],
          [/Ionian #5/gi, 'Ion. #5'],
          [/Dorian #4/gi, 'Dor. #4'],
          [/Aeolian b5/gi, 'Aeol. b5'],
          [/Altered Scale\s*\(Super Locrian\)/gi, 'Super Locrian'],
          [/Combination Diminished\s*\(Half[–-]Whole\)/gi, 'Dim. H–W'],
          [/Diminished\s*\(Whole[–-]Half\)/gi, 'Dim. W–H'],
          [/Japanese Scale\s*\(In Sen\)/gi, 'In Sen'],
          [/Japanese Scale\s*\(In\)/gi, 'In'],
          [/Japanese Scale\s*\(Yo\)/gi, 'Yo'],
          [/Mixolydian b9 b13 \(HP5\)/g, 'HP5'],
          [/Neapolitan Minor/g, 'N-Minor'],
          [/Double Harmonic Major/g, 'D-Harm. M.'],
          [/Harmonic Major/g,'Harm. Maj.'],
          [/Harmonic Minor/g,'Harm. Min.'],
          [/Double Harmonic/g,'Dbl Harm.'],
          [/Neapolitan/g,'Neap.'],
          [/Mixolydian/g,'Mixolyd.'],
          [/Lydian/g,'Lyd.'],
          [/Ionian/g,'Ion.'],
          [/Aeolian/g,'Aeol.'],
          [/Persian Scale/g,'Persian'],
          [/Augmented/g,'Aug.'],
          [/Diminished/g,'Dim.'],
          [/Altered/g,'Alt.']
        ];
        let out = String(txt);
        for (const [r,s] of repl){ out = out.replace(r,s); }
        return out;
      }

      const MIN_GAP_MM = 3, LANE_OFFSET_MM = 4.2, NEAR_X_MM = 6;
      function layoutLabels(items, xStartMm, wMm, lanes, yDir, basePt, bold){
        const nodes = items.map((it,i)=>({ i, text:it.text, cx: xStartMm + it.x * wMm }))
                           .sort((a,b)=>a.cx-b.cx);
        const laneRight = Array(lanes).fill(-1e9);
        const lastCx = Array(lanes).fill(-1e9);
        let lastUsedLane = -1;
        const placed = [];
        nodes.forEach(n=>{
          const valText = n.text || '';
          let w = Math.max(4, measureTextMm(valText, basePt, bold));
          let lane = 0;
          while (lane < lanes){
            const leftMm = n.cx - w/2;
            const farEnoughX = (n.cx - lastCx[lane]) >= NEAR_X_MM;
            if (leftMm > laneRight[lane] + MIN_GAP_MM && farEnoughX) break;
            lane++;
          }
          if (lane >= lanes) lane = lanes - 1;
          if (lanes>=2 && lastUsedLane===lane){
            const tooClose = Math.abs(n.cx - lastCx[lane]) < (NEAR_X_MM*1.2);
            if (tooClose){ lane = (lane+1)%lanes; }
          }
          let scale = 1.0;
          while ((n.cx - (w*scale)/2) <= (laneRight[lane] + MIN_GAP_MM) && scale > 0.8){
            scale -= 0.05;
          }
          const fitPt = basePt * scale;
          const fitW  = w * scale;
          const right = Math.min(xStartMm + wMm, n.cx + fitW/2);
          laneRight[lane] = right;
          lastCx[lane] = n.cx;
          lastUsedLane = lane;
          placed.push({ i:n.i, cx:n.cx, yOffsetMm: yDir * (lane * LANE_OFFSET_MM), fitPt });
        });
        placed.sort((a,b)=>a.i-b.i);
        return placed;
      }

      const staffH = 12, staffGap = staffH/4;
      const topOffsets = { chord:-5, staff:0, text: staffH - 6, scale: staffH + 5 };
      const systemInnerH = staffH + 12, systemSpacing = 6;

      let cursorY = margin.top;
      if (titleText){ textAt(titleText, margin.left, cursorY, {pt:14}); cursorY += 8; }
      if (scoreKey){  textAt(`Key: ${scoreKey}`, margin.left, cursorY, {pt:10}); cursorY += 10; } else { cursorY += 4; }

      let measureNo = 1;
      for (let r=0; r<rowsState.length; r++){
        const row = rowsState[r]; const frSum = row.reduce((a,b)=>a+b,0) || 1;
        const needH = systemInnerH + systemSpacing;
        if (cursorY + needH > (pageH - margin.bottom)){
          doc.addPage();
          cursorY = margin.top;
        }

        const staffTop = cursorY + topOffsets.staff;

        for (let i=0;i<5;i++){
          const y = staffTop + i*staffGap;
          line(margin.left, y, margin.left + contentW, y, 0.35);
        }
        line(margin.left, staffTop, margin.left, staffTop + staffH, 0.5);
        line(margin.left + contentW, staffTop, margin.left + contentW, staffTop + staffH, 0.5);

        let xCursor = margin.left;

        for (let c=0; c<row.length; c++){
          const fr = row[c]; const wMm = contentW * (fr / frSum);
          if (c>0) line(xCursor, staffTop, xCursor, staffTop + staffH, 0.35);
          textAt(String(measureNo), xCursor + 2, staffTop - 2.5, {pt:8});

          const cell = (placementsState[r] && placementsState[r][c]) || { chords:[], texts:[], scales:[] };

          const chordItems = (cell.chords||[]);
          if (chordItems.length){
            const layoutC = layoutLabels(chordItems, xCursor, wMm, 3, -1, 11, true);
            for (let i=0;i<layoutC.length;i++){
              const p = layoutC[i];
              const yC = staffTop + topOffsets.chord + p.yOffsetMm;
              const cx = xCursor + chordItems[i].x * wMm;
              textAt(chordItems[i].text, cx, yC, {align:'center', bold:true, pt:p.fitPt, maxWmm: Math.min(wMm - 3, 30)});
            }
          }

          const textItems = (cell.texts||[]);
          if (textItems.length){
            const layoutT = layoutLabels(textItems, xCursor, wMm, 2, +1, 9, false);
            for (let j=0;j<layoutT.length;j++){
              const p = layoutT[j];
              const yT = staffTop + topOffsets.text + p.yOffsetMm;
              const cx = xCursor + textItems[j].x * wMm;
              drawTextWithBox(textItems[j].text || '', cx, yT, p.fitPt);
            }
          }

          const scaleItems = (cell.scales||[]);
          if (scaleItems.length){
            const layoutS = layoutLabels(scaleItems, xCursor, wMm, 2, +1, 9, false);
            for (let j=0;j<layoutS.length;j++){
              const p = layoutS[j];
              const yS = staffTop + topOffsets.scale + p.yOffsetMm;
              const cx = xCursor + scaleItems[j].x * wMm;
              textAt(abbreviateScaleName(scaleItems[j].text), cx, yS, {align:'center', pt:p.fitPt, maxWmm: Math.min(wMm - 3, 26)});
            }
          }

          xCursor += wMm; measureNo++;
        }

        cursorY += systemInnerH + systemSpacing;
      }

      const filename = (titleText && titleText.trim()) ? `${titleText}.pdf` : 'score.pdf';
      doc.save(filename);
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(App, null));
  </script>
</body>
</html>
